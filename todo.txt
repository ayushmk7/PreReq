OCI Integration Backlog (Deep / Full Setup)

1) OCI tenancy and compartment structure
- Create compartments: conceptlens-dev, conceptlens-stage, conceptlens-prod.
- Define naming and tagging convention (project=conceptlens, env, owner, costCenter).
- Confirm home region and choose a secondary region for DR drills.

2) IAM and least-privilege access
- Create groups: conceptlens-admins, conceptlens-deployers, conceptlens-ops-readonly.
- Create dynamic groups for runtime workloads (API and worker containers).
- Apply least-privilege policies for Vault, OCIR, Object Storage, Queue, Logging, Monitoring, and PostgreSQL access.

3) Networking baseline
- Create VCN with separate public and private subnets.
- Put Load Balancer in public subnet; keep API/worker and DB in private subnets.
- Configure NSGs and route tables to restrict ingress/egress paths.
- Add HTTPS termination with managed certificates and DNS records.

4) Secrets and configuration
- Create OCI Vault and keys.
- Store secrets: DATABASE_URL, OPENAI_API_KEY, INSTRUCTOR_USERNAME, INSTRUCTOR_PASSWORD.
- Move runtime config to secret references; remove server-side plaintext env storage.

5) Data plane (PostgreSQL and storage)
- Provision OCI Database with PostgreSQL for app metadata and compute results.
- Run Alembic migrations and validate schema integrity.
- Create Object Storage buckets: frontend-static, uploads, exports, backups.
- Configure lifecycle rules for retention and cost control.

6) Runtime delivery (manual, no CI/CD)
- Build backend and worker container images.
- Push images to OCIR manually.
- Deploy API and worker on OCI Container Instances.
- Configure health checks and autoscaling policy boundaries (manual scale actions initially).

7) Frontend delivery
- Build frontend static bundle and upload to frontend-static bucket.
- Configure Object Storage static website hosting and OCI CDN.
- Set VITE_API_BASE_URL to OCI API endpoint and validate end-to-end flows.

8) Async compute migration readiness
- Keep existing run tracking model (run_id and status fields).
- Convert /compute into submit + status endpoints for queue-driven execution.
- Add worker polling and retry semantics with idempotency key by exam_id + run_id.
- Preserve intervention/report behavior and API response compatibility.

9) Observability and alerting
- Enable OCI Logging for Load Balancer, Container Instances, and API app logs.
- Create Monitoring metrics and alarms: 5xx count, p95 latency, DB connectivity failures, queue lag.
- Add runbooks for incident response and rollback.

10) Security hardening
- Replace permissive CORS in production with allowed origins list.
- Replace placeholder auth with production auth (JWT/OIDC or API gateway auth policy).
- Enforce TLS in transit and at-rest encryption defaults for DB and Object Storage.

11) Disaster recovery and backups
- Configure daily DB backups and periodic restore tests.
- Define RPO and RTO targets and document failover checklist.
- Export critical config as code artifacts (where possible) for reproducible recovery.

12) Day-1 execution checklist (what to do now)
- Create compartments and IAM groups/policies.
- Provision PostgreSQL and save DATABASE_URL in Vault.
- Create Object Storage buckets and lifecycle policies.
- Deploy backend container in OCI and validate /health and /docs.
- Publish frontend to Object Storage + CDN and point DNS.
- Run smoke test: upload scores -> upload mapping -> compute -> instructor dashboard/report.
